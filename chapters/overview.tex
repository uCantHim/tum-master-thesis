\chapter{Overview}

\section{Focaccia's Position in the Software Testing Landscape}

We want to tests binary translators, particularly emulators. "Testing is defined as a process of evaluation that either
the specific system meets its originally specified requirements or not"~\cite{jamil2016software_testing}. As formalized
in section~\ref{sec:definitions}, the fundamental correctness requirement of binary translators is semantic equivalence
between input- and output programs, that is, between the translated program and the translation. Violation of this
requirement is a bug specific to binary translators, and Focaccia aims to implement an automated detection algorithm for
it.

In the domain of automated testing, our specific interest can be categorized as \textit{correctness testing}. We can
further refine the classification by considering that the algorithm effectively compares the program's output to an
expected oracle-based output, with no knowledge about the tested program's internal structure: it is a \textit{black
box} approach~\cite{sawant2012software}. Thus, it inherits many of the common problems of black box testing:

\begin{itemize}
    \item The set of testable input permutations is very restricted because test cases must be written manually.
    \item Tests are likely to establish a lower bound on program functionality (`it does at least what it is required to
        do'), but not an upper bound.
    \item Does not maximize code-/branch coverage.
\end{itemize}

Focaccia removes the necessity to define correct reference results for test cases by computing them automatically,
relieving the burden of an additional source of errors in tests, though the necessity of generating the test cases
themselves persists. It is therefore combinable with many of the existing techniques, paradigms, and structured
approaches for unit testing~\cite{jan2016innovative}~\cite{yu2011robust_planning}:

\begin{itemize}
    \item Equivalence Partitioning: Define classes of input values that are treated equivalently by the program, i.e.
        which can be tested exhaustively by running tests on only a single element of the class.
    \item Boundary Value Analysis: Define test cases that cover specifically the boundaries of equivalence classes.
    \item Orthogonal Array Testing: Further minimize the number of test cases required when equivalence partitioning is
        in place by constructing a matrix of test input combinations.
    \item Fuzzing: Automated technique that generates random inputs to the tested function.
    \item And more, like graph-based testing, all pair testing, or state transition testing.
\end{itemize}

\section{Goals}

\section{Challenges}

This is a short summary of the challenges that Focaccia's development had to overcome. Many of these problems may not be
obvious, or even understandable, from the descriptions given thus far. See chapter~\ref{chapter:design}, particularly
section~\ref{sec:abstract_algo}, for detailed descriptions of their origin, justification, exploration, and final
resolution. For now, they have to stand as given.

\subsection{Acquiring Data from Emulators}

\subsection{Program Trace Mismatches}
