@book{latex,
  title = {LaTeX : A Documentation Preparation System User's Guide and Reference Manual},
  publisher = {Addison-Wesley Professional},
  year = {1994},
  author = {Leslie Lamport}
}

@misc{Z3prover2024Mar,
  author = {Z3prover},
  title = {{z3}},
  journal = {GitHub},
  year = {2024},
  month = mar,
  note = {[Online; accessed 11. Mar. 2024]},
  url = {https://github.com/Z3Prover/z3}
}

@Inbook{Steinhöfel2022,
  author="Steinh{\"o}fel, Dominic",
  editor="Ahrendt, Wolfgang
  and Beckert, Bernhard
  and Bubel, Richard
  and Johnsen, Einar Broch",
  title="Symbolic Execution: Foundations, Techniques, Applications, and Future Perspectives",
  bookTitle="The Logic of Software. A Tasting Menu of Formal Methods: Essays Dedicated to Reiner H{\"a}hnle on the Occasion of His 60th Birthday",
  year="2022",
  publisher="Springer International Publishing",
  address="Cham",
  pages="446--480",
  abstract="Symbolic Execution (SE) enables a precise, deep program exploration by executing programs with symbolic inputs. Traditionally, the SE community is divided into the rarely interacting sub-communities of bug finders and program provers. This has led to independent developments of related techniques, and biased surveys and foundational papers. As both communities focused on their specific problems, the foundations of SE as a whole were not sufficiently studied. We attempt an unbiased account on the foundations, central techniques, current applications, and future perspectives of SE. We first describe essential design elements of symbolic executors, supported by implementations in a digital companion volume. We recap a semantic framework, and derive from it a---yet unpublished---automatic testing approach for SE engines. Second, we introduce SE techniques ranging from concolic execution over compositional SE to state merging. Third, we discuss applications of SE, including test generation, program verification, and symbolic debugging. Finally, we address the future. Google's OSS-Fuzz project routinely detects thousands of bugs in hundreds of major open source projects. What can symbolic execution contribute to future software verification in the presence of such competition?",
  isbn="978-3-031-08166-8",
  doi="10.1007/978-3-031-08166-8_22",
  url="https://doi.org/10.1007/978-3-031-08166-8_22"
}

@inproceedings{shoshitaishvili2016state,
  title={{SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis}},
  author={Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and
          Stephens, Nick and Polino, Mario and Dutcher, Audrey and Grosen, John and
          Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
  booktitle={IEEE Symposium on Security and Privacy},
  year={2016}
}

@misc{AngrWebsite2024Mar,
  title = {{angr}},
  year = {2024},
  month = mar,
  note = {[Online; accessed 25. Mar. 2024]},
  url = {https://angr.io}
}

@article{desclaux2012miasm,
  title={Miasm: Framework de reverse engineering},
  author={Desclaux, Fabrice},
  journal={Actes du sstic. sstic},
  year={2012}
}

@misc{cea-sec2024Mar,
  author = {cea-sec},
  title = {{miasm}},
  year = {2024},
  month = mar,
  note = {[Online; accessed 25. Mar. 2024]},
  url = {https://github.com/cea-sec/miasm}
}

@INPROCEEDINGS{jamil2016software_testing,
  author={Jamil, Muhammad Abid and Arif, Muhammad and Abubakar, Normi Sham Awang and Ahmad, Akhlaq},
  booktitle={2016 6th International Conference on Information and Communication Technology for The Muslim World (ICT4M)},
  title={Software Testing Techniques: A Literature Review},
  year={2016},
  volume={},
  number={},
  pages={177-182},
  keywords={Software;Software testing;Automation;Computer bugs;Quality assurance;Planning;Testing Methodologies;Software Testing Life Cycle;Testing Frameworks;Automation Testing;Test Driven Development;Test optimisation;Quality Metrics},
  doi={10.1109/ICT4M.2016.045}
}

@article{sawant2012software,
  title={Software testing techniques and strategies},
  author={Sawant, Abhijit A and Bari, Pranit H and Chawan, PM},
  journal={International Journal of Engineering Research and Applications (IJERA)},
  volume={2},
  number={3},
  pages={980--986},
  year={2012}
}

@article{jan2016innovative,
  title={An innovative approach to investigate various software testing techniques and strategies},
  author={Jan, S Roohullah and Shah, S Tauhid Ullah and Johar, Z Ullah and Shah, Yasin and Khan, Fazlullah},
  journal={Int. J. Sci. Res. Sci. Eng. Technol},
  volume={2},
  number={2},
  pages={682--689},
  year={2016}
}

@article{yu2011robust_planning,
  author={Yu, Han and Chung, C. Y. and Wong, K. P.},
  journal={IEEE Transactions on Power Systems},
  title={Robust Transmission Network Expansion Planning Method With Taguchi's Orthogonal Array Testing},
  year={2011},
  volume={26},
  number={3},
  pages={1573-1580},
  keywords={Testing;Planning;Arrays;Renewable energy resources;Robustness;Optimization;Robust design;Taguchi's orthogonal array testing;transmission network expansion planning;uncertainty},
  doi={10.1109/TPWRS.2010.2082576}
}

@misc{MuslLibc2024Feb,
	title = {{musl libc}},
	year = {2024},
	month = feb,
	note = {[Online; accessed 1. Apr. 2024]},
	url = {https://musl.libc.org}
}

@misc{getauxval2024Mar,
	title = {{getauxval(3) - Linux manual page}},
	year = {2024},
	month = mar,
	note = {[Online; accessed 1. Apr. 2024]},
	url = {https://www.man7.org/linux/man-pages/man3/getauxval.3.html}
}

@article{Baldoni2018SymbexecSurvey,
  author = {Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
  title = {A Survey of Symbolic Execution Techniques},
  year = {2018},
  issue_date = {May 2019},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {51},
  number = {3},
  issn = {0360-0300},
  url = {https://doi.org/10.1145/3182657},
  doi = {10.1145/3182657},
  abstract = {Many security and software testing applications require checking whether certain properties of a program hold for any possible usage scenario. For instance, a tool for identifying software vulnerabilities may need to rule out the existence of any backdoor to bypass a program’s authentication. One approach would be to test the program using different, possibly random inputs. As the backdoor may only be hit for very specific program workloads, automated exploration of the space of possible inputs is of the essence. Symbolic execution provides an elegant solution to the problem, by systematically exploring many possible execution paths at the same time without necessarily requiring concrete inputs. Rather than taking on fully specified input values, the technique abstractly represents them as symbols, resorting to constraint solvers to construct actual instances that would cause property violations. Symbolic execution has been incubated in dozens of tools developed over the past four decades, leading to major practical breakthroughs in a number of prominent software reliability applications. The goal of this survey is to provide an overview of the main ideas, challenges, and solutions developed in the area, distilling them for a broad audience.},
  journal = {ACM Comput. Surv.},
  month = {may},
  articleno = {50},
  numpages = {39},
  keywords = {static analysis, software testing, concolic execution, Symbolic execution}
}

@article{Boyer1975Select,
 author = {Boyer, Robert S. and Elspas, Bernard and Levitt, Karl N.},
 title = {SELECT—a formal system for testing and debugging programs by symbolic execution},
 year = {1975},
 issue_date = {June 1975},
 publisher = {Association for Computing Machinery},
 address = {New York, NY, USA},
 volume = {10},
 number = {6},
 issn = {0362-1340},
 url = {https://doi.org/10.1145/390016.808445},
 doi = {10.1145/390016.808445},
 abstract = {SELECT is an experimental system for assisting in the formal systematic debugging of programs. It is intended to be a compromise between an automated program proving system and the current ad hoc debugging practice, and is similar to a system being developed by King et al. of IBM. SELECT systematically handles the paths of programs written in a LISP subset that includes arrays. For each execution path SELECT returns simplified conditions on input variables that cause the path to be executed, and simplified symbolic values for program variables at the path output. For conditions which form a system of linear equalities and inequalities SELECT will return input variable values that can serve as sample test data. The user can insert constraint conditions, at any point in the program including the output, in the form of symbolically executable assertions. These conditions can induce the system to select test data in user-specified regions. SELECT can also determine if the path is correct with respect to an output assertion. We present four examples demonstrating the various modes of system operation and their effectiveness in finding bugs. In some examples, SELECT was successful in automatically finding useful test data. In others, user interaction was required in the form of output assertions. SELECT appears to be a useful tool for rapidly revealing program errors, but for the future there is a need to expand its expressive and deductive power.},
 journal = {SIGPLAN Not.},
 month = {apr},
 pages = {234–245},
 numpages = {12},
 keywords = {Test data generation, Symbolic execution, Solution of systems of inequalities, Program verification, Program testing, Program debugging}
}

@article{King1975Effigy,
  author = {King, James C.},
  title = {A new approach to program testing},
  year = {1975},
  issue_date = {June 1975},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {10},
  number = {6},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/390016.808444},
  doi = {10.1145/390016.808444},
  abstract = {The current approach for testing a program is, in principle, quite primitive. Some small sample of the data that a program is expected to handle is presented to the program. If the program produces correct results for the sample, it is assumed to be correct. Much current work focuses on the question of how to choose this sample. We propose that a program can be more effectively tested by executing it "symbolically." Instead of supplying specific constants as input values to a program being tested, one supplies symbols. The normal computational definitions for the basic operations performed by a program can be expanded to accept symbolic inputs and produce symbolic formulae as output. If the flow of control in the program is completely independent of its input parameters, then all output values can be symbolically computed as formulae over the symbolic inputs and examined for correctness. When the control flow of the program is input dependent, a case analysis can be performed producing output formulae for each class of inputs determined by the control flow dependencies. Using these ideas, we have designed and implemented an interactive debugging/testing system called EFFIGY.},
  journal = {SIGPLAN Not.},
  month = {apr},
  pages = {228–233},
  numpages = {6},
  keywords = {Symbolic interpretation, Symbolic execution, Program verification, Program testing, Program correctness}
}

@article{King1976SymbExec,
  author = {King, James C.},
  title = {Symbolic execution and program testing},
  year = {1976},
  issue_date = {July 1976},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {19},
  number = {7},
  issn = {0001-0782},
  url = {https://doi.org/10.1145/360248.360252},
  doi = {10.1145/360248.360252},
  abstract = {This paper describes the symbolic execution of programs. Instead of supplying the normal inputs to a program (e.g. numbers) one supplies symbols representing arbitrary values. The execution proceeds as in a normal execution except that values may be symbolic formulas over the input symbols. The difficult, yet interesting issues arise during the symbolic execution of conditional branch type statements. A particular system called EFFIGY which provides symbolic execution for program testing and debugging is also described. It interpretively executes programs written in a simple PL/I style programming language. It includes many standard debugging features, the ability to manage and to prove things about symbolic expressions, a simple program testing manager, and a program verifier. A brief discussion of the relationship between symbolic execution and program proving is also included.},
  journal = {Commun. ACM},
  month = {jul},
  pages = {385–394},
  numpages = {10},
  keywords = {program debugging, program proving, program testing, program verification, symbolic execution, symbolic interpretation}
}

@article{Howden1977Dissect,
  author={Howden, W.E.},
  journal={IEEE Transactions on Software Engineering},
  title={Symbolic Testing and the DISSECT Symbolic Evaluation System},
  year={1977},
  volume={SE-3},
  number={4},
  pages={266-278},
  keywords={System testing;Programming profession;Software testing;Computer bugs;Data analysis;Error correction;Software reliability;Table lookup;Physics;Information science;Automated aids;data flow analysis;program correctness;program specifications;program testing;software errors;software reliability;symbolic evaluation;test data generation},
  doi={10.1109/TSE.1977.231144}
}

@article{Agha+2005Cute,
  author = {Sen, Koushik and Marinov, Darko and Agha, Gul},
  title = {CUTE: a concolic unit testing engine for C},
  year = {2005},
  issue_date = {September 2005},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {30},
  number = {5},
  issn = {0163-5948},
  url = {https://doi.org/10.1145/1095430.1081750},
  doi = {10.1145/1095430.1081750},
  abstract = {In unit testing, a program is decomposed into units which are collections of functions. A part of unit can be tested by generating inputs for a single entry function. The entry function may contain pointer arguments, in which case the inputs to the unit are memory graphs. The paper addresses the problem of automating unit testing with memory graphs as inputs. The approach used builds on previous work combining symbolic and concrete execution, and more specifically, using such a combination to generate test inputs to explore all feasible execution paths. The current work develops a method to represent and track constraints that capture the behavior of a symbolic execution of a unit with memory graphs as inputs. Moreover, an efficient constraint solver is proposed to facilitate incremental generation of such test inputs. Finally, CUTE, a tool implementing the method is described together with the results of applying CUTE to real-world examples of C code.},
  journal = {SIGSOFT Softw. Eng. Notes},
  month = {sep},
  pages = {263–272},
  numpages = {10},
  keywords = {concolic testing, data structure testing, explicit path model-checking, random testing, testing C programs, unit testing}
}

@inproceedings{Sen2007ConcolicTesting,
  author = {Sen, Koushik},
  title = {Concolic testing},
  year = {2007},
  isbn = {9781595938824},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/1321631.1321746},
  doi = {10.1145/1321631.1321746},
  abstract = {Concolic testing automates test input generation by combining the concrete and symbolic (concolic) execution of the code under test. Traditional test input generation techniques use either (1) concrete execution or (2) symbolic execution that builds constraints and is followed by a generation of concrete test inputs from these constraints. In contrast, concolic testing tightly couples both concrete and symbolic executions: they run simultaneously, and each gets feedback from the other.We have implemented concolic testing in tools for testing both C and Java programs. We have used the tools to find bugs in several real-world software systems including SGLIB, a popular C data structure library used in a commercial tool, a third-party implementation of the Needham-Schroeder protocol and the TMN protocol, the scheduler of Honeywell's DEOS real-time operating system, and the Sun Microsystems' JDK 1.4 collection framework. In this tutorial, we will describe concolic testing and some of its recent extensions},
  booktitle = {Proceedings of the 22nd IEEE/ACM International Conference on Automated Software Engineering},
  pages = {571–572},
  numpages = {2},
  keywords = {unit testing, testing tools, testing C programs, symbolic execution, random testing, explicit path model-checking, data structure testing, concolic testing},
  location = {Atlanta, Georgia, USA},
  series = {ASE '07}
}

@article{Borzacchiello2021Fuzzolic,
  title = {FUZZOLIC: Mixing fuzzing and concolic execution},
  journal = {Computers \& Security},
  volume = {108},
  pages = {102368},
  year = {2021},
  issn = {0167-4048},
  doi = {https://doi.org/10.1016/j.cose.2021.102368},
  url = {https://www.sciencedirect.com/science/article/pii/S0167404821001929},
  author = {Luca Borzacchiello and Emilio Coppa and Camil Demetrescu},
  keywords = {Bug detection, Concolic execution, Fuzzing testing, SMT Solver, Hybrid fuzzing},
  abstract = {In the last few years, a large variety of approaches and methodologies have been explored in the context of software testing, ranging from black-box techniques, such as fuzzing, to white-box techniques, such as concolic execution, with a full spectrum of instances in between. Using these techniques, developers and security researchers have been able to identify in the last decade a large number of critical vulnerabilities in thousands of software projects. In this article, we investigate how to improve the performance and effectiveness of concolic execution, proposing two main enhancements to the original approach. On one side, we devise a novel concolic executor that can analyze complex binary programs while running under QEMU and efficiently produce symbolic queries, which could generate valuable program inputs when solved. On the other side, we investigate whether techniques borrowed from the fuzzing domain can be applied to solve the symbolic queries generated by concolic execution, providing a viable alternative to accurate but expensive SMT solving techniques. We show that the combination of our concolic engine, Fuzzolic, and our approximate solver, Fuzzy-Sat, can perform better in terms of code coverage than popular state-of-the-art fuzzers on a variety of complex programs and can identify different unknown bugs in several real-world applications.}
}
